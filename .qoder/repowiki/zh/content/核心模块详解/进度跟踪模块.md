# 进度跟踪模块

<cite>
**本文档中引用的文件**  
- [progress_provider.dart](file://app/lib/provider/progress_provider.dart)
- [custom_progress_bar.dart](file://app/lib/widget/custom_progress_bar.dart)
- [progress_page.dart](file://app/lib/pages/progress_page.dart)
- [file_speed_helper.dart](file://app/lib/util/file_speed_helper.dart)
- [sending_file.dart](file://app/lib/model/state/send/sending_file.dart)
- [send_provider.dart](file://app/lib/provider/network/send_provider.dart)
</cite>

## 目录
1. [简介](#简介)
2. [文件传输进度计算方法](#文件传输进度计算方法)
3. [ProgressProvider状态管理器](#progressprovider状态管理器)
4. [SendingFile模型设计](#sendingfile模型设计)
5. [自定义进度条实现](#自定义进度条实现)
6. [多文件批量传输总体进度聚合](#多文件批量传输总体进度聚合)
7. [进度数据采样频率与性能优化](#进度数据采样频率与性能优化)
8. [模块协同工作与用户体验反馈](#模块协同工作与用户体验反馈)

## 简介
进度跟踪模块是LocalSend应用中的核心组件，负责实时监控和展示文件传输过程中的各种进度信息。该模块通过精确的字节统计、传输速率计算和状态管理，为用户提供直观的传输进度反馈。本模块主要由ProgressProvider状态管理器、SendingFile数据模型和CustomProgressBar UI组件构成，通过高效的性能优化策略确保UI流畅性。

## 文件传输进度计算方法

### 已传输字节数与总字节数统计
文件传输进度的计算基于已传输字节数和总字节数的实时统计。系统通过ProgressProvider中的_progressMap存储每个会话(session)和文件(file)的进度信息，进度值以0到1之间的浮点数表示。

在ProgressPage中，通过以下方式计算当前已传输的总字节数：
```dart
final currBytes = _files.fold<int>(
    0, (prev, curr) => prev + ((progressNotifier.getProgress(sessionId: widget.sessionId, fileId: curr.id) * curr.size).round()));
```
此计算将每个文件的进度乘以其大小，然后累加得到总已传输字节数。

### 传输速率实时统计机制
传输速率的计算通过file_speed_helper.dart中的getFileSpeed函数实现。该函数基于时间差和已传输字节数来计算每秒传输的字节数：

```dart
int getFileSpeed({
  required int start,
  required int end,
  required int bytes,
}) {
  final deltaTime = end - start;
  return (_millisecondsPerSecond * bytes) ~/ deltaTime;
}
```

系统在ProgressPage中调用此函数来获取实时传输速率：
```dart
if (startTime != null && currBytes >= 500 * 1024) {
  speedInBytes = getFileSpeed(start: startTime, end: endTime ?? DateTime.now().millisecondsSinceEpoch, bytes: currBytes);
}
```

### 剩余时间预测算法
剩余时间的预测通过getRemainingTime函数实现，该函数根据当前传输速率和剩余字节数计算预计完成时间：

```dart
String getRemainingTime({
  required int bytesPerSeconds,
  required int remainingBytes,
}) {
  if (bytesPerSeconds == 0) {
    return remainingBytes == 0 ? t.progressPage.remainingTime.seconds(n: 0, ss: '00') : '∞';
  }

  final remainingTimeInSeconds = _getRemainingTime(bytesPerSeconds: bytesPerSeconds, remainingBytes: remainingBytes);
  // 根据时间长度返回不同格式的字符串
  if (remainingTimeInSeconds < _secondsPerMinute) {
    return t.progressPage.remainingTime.seconds(n: 0, ss: remainingTimeInSeconds.toString().padLeft(2, '0'));
  } else if (remainingTimeInSeconds < _secondsPerHour) {
    // 分钟和秒格式
  } else if (remainingTimeInSeconds < _secondsPerDay) {
    // 小时和分钟格式
  } else {
    // 天、小时和分钟格式
  }
}
```

**Section sources**
- [file_speed_helper.dart](file://app/lib/util/file_speed_helper.dart#L0-L51)
- [progress_page.dart](file://app/lib/pages/progress_page.dart#L178-L211)

## ProgressProvider状态管理器

### 实现原理
ProgressProvider是基于ChangeNotifierProvider实现的状态管理器，用于高效地管理文件传输进度。它使用_progressMap来存储每个会话和文件的进度信息：

```dart
final _progressMap = <String, Map<String, double>>{}; // session id -> (file id -> 0..1)
```

### 核心方法
ProgressProvider提供了以下核心方法来管理进度状态：

- **setProgress**: 设置指定会话和文件的进度值，并触发UI更新
- **getProgress**: 获取指定会话和文件的当前进度
- **removeSession**: 移除整个会话的进度信息
- **removeAllSessions**: 清除所有会话的进度信息

当调用setProgress方法时，系统会自动调用notifyListeners()，通知所有监听此Provider的UI组件进行更新。

### 状态通知机制
ProgressProvider通过ref.watch(progressProvider)在ProgressPage中被监听，当进度发生变化时，UI会自动重建。这种基于ChangeNotifier的实现方式确保了性能优化，只有当实际进度发生变化时才会触发UI更新。

```dart
final progressNotifier = ref.watch(progressProvider);
```

**Section sources**
- [progress_provider.dart](file://app/lib/provider/progress_provider.dart#L0-L37)
- [progress_page.dart](file://app/lib/pages/progress_page.dart#L178-L211)

## SendingFile模型设计

### 进度相关字段
SendingFile模型定义了文件传输过程中的各种状态信息，其中与进度相关的关键字段包括：

- **status**: FileStatus枚举类型，表示文件的当前状态（queue, skipped, sending, failed, finished）
- **token**: 用于标识文件传输的令牌
- **errorMessage**: 当传输失败时存储错误信息

```dart
@MappableClass()
class SendingFile with SendingFileMappable {
  final FileDto file;
  final FileStatus status;
  final String? token;
  final Uint8List? thumbnail;
  final AssetEntity? asset;
  final String? path;
  final List<int>? bytes;
  final String? errorMessage;
}
```

### 状态更新策略
SendingFile的状态更新通过send_provider.dart中的sendFile方法实现。当文件传输状态发生变化时，系统会更新SendingFile的状态并通知ProgressProvider：

```dart
state = state.updateSession(
  sessionId: sessionId,
  state: (s) => s?.withFileStatus(file.file.id, FileStatus.sending, null),
);
```

当文件传输完成时，系统会将进度设置为100%：

```dart
ref.notifier(progressProvider).setProgress(
  sessionId: sessionId,
  fileId: file.file.id,
  progress: 1,
);
```

**Section sources**
- [sending_file.dart](file://app/lib/model/state/send/sending_file.dart#L0-L37)
- [send_provider.dart](file://app/lib/provider/network/send_provider.dart#L384-L579)

## 自定义进度条实现

### CustomProgressBar组件
CustomProgressBar是基于Flutter的LinearProgressIndicator实现的自定义进度条组件，提供了更灵活的样式控制：

```dart
class CustomProgressBar extends StatelessWidget {
  final double? progress;
  final double borderRadius;
  final Color? color;

  const CustomProgressBar({required this.progress, this.borderRadius = 10, this.color});

  @override
  Widget build(BuildContext context) {
    return ClipRRect(
      borderRadius: BorderRadius.circular(borderRadius),
      child: LinearProgressIndicator(
        value: progress,
        color: color ?? Theme.of(context).colorScheme.primary,
        minHeight: 10,
      ),
    );
  }
}
```

### 动画效果实现
在ProgressPage中，通过TweenAnimationBuilder为进度条添加平滑的动画效果：

```dart
TweenAnimationBuilder(
  tween: Tween<double>(begin: 0, end: _totalBytes == 0 ? 0 : currBytes / _totalBytes),
  duration: const Duration(milliseconds: 200),
  curve: Curves.easeOut,
  builder: (context, value, child) {
    return CustomProgressBar(
      progress: value,
      borderRadius: 5,
    );
  },
)
```

此实现使用Curves.easeOut缓动曲线，在200毫秒内完成进度变化的动画过渡，提供流畅的视觉体验。

**Section sources**
- [custom_progress_bar.dart](file://app/lib/widget/custom_progress_bar.dart#L0-L21)
- [progress_page.dart](file://app/lib/pages/progress_page.dart#L435-L460)

## 多文件批量传输总体进度聚合

### 聚合算法
多文件批量传输的总体进度通过加权平均算法计算。系统遍历所有文件，根据每个文件的进度和大小计算总进度：

```dart
final currBytes = _files.fold<int>(
    0, (prev, curr) => prev + ((progressNotifier.getProgress(sessionId: widget.sessionId, fileId: curr.id) * curr.size).round()));
```

总体进度的计算公式为：
```
总体进度 = Σ(单个文件进度 × 单个文件大小) / 总文件大小
```

### 高级信息展示
在高级模式下，系统会显示更详细的进度信息，包括：

- 已完成文件数量：`Text(t.progressPage.total.count(curr: finishedCount, n: _selectedFiles.length))`
- 已传输数据量：`Text(t.progressPage.total.size(curr: currBytes.asReadableFileSize, n: _totalBytes.asReadableFileSize))`
- 传输速率：`Text(t.progressPage.total.speed(speed: speedInBytes.asReadableFileSize))`

这些信息通过AnimatedCrossFade组件实现平滑的展开/收起动画效果。

**Section sources**
- [progress_page.dart](file://app/lib/pages/progress_page.dart#L459-L483)

## 进度数据采样频率与性能优化

### 采样频率控制
为避免过度频繁的状态更新影响UI流畅性，系统实现了智能的采样频率控制机制。剩余时间的更新被限制为每秒最多一次：

```dart
final now = DateTime.now().millisecondsSinceEpoch;
if (now - _lastRemainingTimeUpdate >= 1000) {
  _remainingTime = getRemainingTime(bytesPerSeconds: speedInBytes, remainingBytes: _totalBytes - currBytes);
  _lastRemainingTimeUpdate = now;
}
```

### 性能优化策略
系统采用了多项性能优化策略：

1. **延迟计算**: 仅在已传输数据量达到500KB以上时才开始计算传输速率，避免小文件传输时的不准确计算
2. **节流更新**: 对剩余时间的计算进行节流，限制更新频率
3. **ChangeNotifier优化**: 使用ChangeNotifierProvider确保只有当实际进度发生变化时才触发UI重建
4. **资源管理**: 在页面销毁时及时清理定时器和唤醒锁，避免资源泄漏

```dart
@override
void dispose() {
  super.dispose();
  _finishTimer?.cancel();
  _wakelockPlusTimer?.cancel();
  TaskbarHelper.clearProgressBar();
  try {
    WakelockPlus.disable();
  } catch (_) {}
}
```

**Section sources**
- [progress_page.dart](file://app/lib/pages/progress_page.dart#L200-L211)
- [progress_page.dart](file://app/lib/pages/progress_page.dart#L260-L280)

## 模块协同工作与用户体验反馈

### 模块协同机制
进度跟踪模块与其他模块通过以下方式协同工作：

1. **与SendProvider协同**: SendProvider在文件传输过程中调用ProgressProvider更新进度
2. **与ServerProvider协同**: 接收端和发送端共享相同的进度信息
3. **与Native模块协同**: 通过TaskbarHelper在系统任务栏显示进度

```dart
if (status == SessionStatus.sending) {
  TaskbarHelper.setProgressBar(currBytes, _totalBytes);
} else if (status != _lastStatus) {
  _lastStatus = status;
  TaskbarHelper.visualizeStatus(status);
}
```

### 用户体验反馈
系统通过多种方式提供用户体验反馈：

1. **视觉反馈**: 使用颜色编码的状态指示（绿色表示成功，黄色表示警告，红色表示错误）
2. **桌面集成**: 在Windows和macOS的任务栏/程序坞中显示进度条和状态图标
3. **声音提示**: 在传输完成或失败时提供声音反馈
4. **唤醒锁**: 在传输过程中保持屏幕常亮，防止传输中断

这些反馈机制共同为用户提供清晰、直观的传输状态信息，确保用户能够及时了解文件传输的进展情况。

**Section sources**
- [progress_page.dart](file://app/lib/pages/progress_page.dart#L190-L200)
- [taskbar_helper.dart](file://app/lib/util/native/taskbar_helper.dart#L37-L87)
# 数据传输

<cite>
**本文档中引用的文件**   
- [webrtc.rs](file://core/src/webrtc/webrtc.rs)
- [security_helper.dart](file://app/lib/util/security_helper.dart)
- [send_provider.dart](file://app/lib/provider/network/send_provider.dart)
- [progress_provider.dart](file://app/lib/provider/progress_provider.dart)
- [file_status.dart](file://common/lib/model/file_status.dart)
- [session_status.dart](file://common/lib/model/session_status.dart)
</cite>

## 目录
1. [介绍](#介绍)
2. [WebRTC数据通道配置](#webrtc数据通道配置)
3. [文件分块传输机制](#文件分块传输机制)
4. [大文件流式处理策略](#大文件流式处理策略)
5. [数据完整性验证](#数据完整性验证)
6. [传输加密方案](#传输加密方案)
7. [性能数据](#性能数据)
8. [结论](#结论)

## 介绍
本文档详细阐述了LocalSend应用的数据传输模块，重点介绍基于WebRTC技术的点对点文件传输系统。该系统通过WebRTC数据通道实现高效、安全的文件共享，支持可靠与不可靠传输模式，并采用分块传输和流式处理策略来优化大文件传输。文档涵盖了从连接建立、数据分块、加密验证到性能监控的完整流程，为开发者和用户提供全面的技术参考。

## WebRTC数据通道配置

LocalSend应用使用WebRTC数据通道（Data Channel）进行点对点文件传输。数据通道的配置在`webrtc.rs`文件中实现，采用有序传输模式以确保数据的完整性和顺序性。

数据通道的建立过程包括以下几个关键步骤：
1. **信令交换**：通过信令服务器交换SDP（Session Description Protocol）信息，建立P2P连接。
2. **非对称密钥交换**：双方交换随机生成的nonce（一次性数值），用于后续的令牌验证。
3. **令牌验证**：基于nonce和公钥生成加密令牌，验证通信双方的身份。
4. **PIN码验证**（可选）：在需要额外安全验证的场景下，通过PIN码进行二次确认。

数据通道的配置参数如下：
```rust
let data_channel = peer_connection
    .create_data_channel(
        CHANNEL_LABEL,
        Some(RTCDataChannelInit {
            ordered: Some(true),
            max_packet_life_time: None,
            max_retransmits: None,
            protocol: None,
            negotiated: None,
        }),
    )
    .await?;
```

传输模式的选择主要体现在`ordered`参数上。LocalSend应用选择`ordered: Some(true)`来确保数据的可靠传输，这意味着数据包将按发送顺序到达，如果出现丢包，系统会自动重传。这种模式适用于文件传输等对数据完整性要求高的场景。虽然WebRTC也支持不可靠传输模式（`ordered: Some(false)`），但LocalSend并未采用，以保证文件传输的可靠性。

**Section sources**
- [webrtc.rs](file://core/src/webrtc/webrtc.rs#L1322-L1373)

## 文件分块传输机制

为了高效传输大文件并优化内存使用，LocalSend应用实现了基于固定大小的分块传输机制。该机制将大文件分割成多个小块进行逐个传输，有效避免了内存溢出问题。

### 分块大小
文件分块的大小在代码中被定义为常量：
```rust
const CHUNK_SIZE: usize = 16 * 1024; // 16 KiB
```
即每个数据块的大小为16 KiB。这个大小是经过权衡的结果：既足够小以减少单次传输的延迟和内存占用，又足够大以保持较高的传输效率。

### 序列号管理与传输确认
分块传输的流程如下：
1. **发送端**：读取文件内容，将其分割成16 KiB大小的数据块，通过数据通道逐个发送。
2. **接收端**：接收数据块，并将其重新组装成完整的文件。
3. **传输确认**：在每个文件传输完成后，接收端会发送一个确认消息（`RTCSendFileResponse`），包含文件ID、传输成功状态和可能的错误信息。

序列号管理通过数据通道的有序传输特性自动实现。由于数据通道配置为`ordered: true`，接收端可以确保数据块按正确的顺序到达，无需额外的序列号字段。

文件传输的状态通过`FileStatus`枚举进行管理：
```dart
enum FileStatus {
  queue,
  skipped,
  sending,
  failed,
  finished,
}
```
发送端和接收端共享这些状态信息，以同步传输进度。

**Section sources**
- [webrtc.rs](file://core/src/webrtc/webrtc.rs#L1234-L1274)
- [file_status.dart](file://common/lib/model/file_status.dart#L0-L13)

## 大文件流式处理策略

LocalSend应用采用流式处理策略来应对大文件传输，有效管理内存并提供实时的进度跟踪。

### 内存管理
流式处理的核心是避免将整个大文件加载到内存中。应用通过异步通道（`mpsc::Receiver<Bytes>`）接收数据，每次只处理一个数据块，处理完成后立即释放内存，从而将内存占用保持在较低水平。

关键的流式处理函数是`process_in_chunks`：
```rust
pub async fn process_in_chunks<T, F, Fut>(
    mut data_channel: T,
    mut rx: mpsc::Receiver<Bytes>,
    mut callback: F,
) -> Result<()>
where
    F: FnMut(T, Bytes) -> Fut,
    Fut: Future<Output = Result<T>>,
{
    let mut buffer = BytesMut::with_capacity(CHUNK_SIZE);
    // ... 处理接收到的数据块
}
```
此函数从接收通道中逐个读取数据块，并调用回调函数进行处理，实现了真正的流式传输。

### 进度跟踪
进度跟踪由`ProgressProvider`负责实现。每当一个数据块被成功处理，进度提供者会更新相应的进度值：
```dart
void setProgress({required String sessionId, required String fileId, required double progress}) {
    // 更新进度映射
    notifyListeners(); // 通知UI更新
}
```
UI组件（如`ProgressPage`）监听这些进度变化，并实时更新进度条和剩余时间显示。

**Section sources**
- [webrtc.rs](file://core/src/webrtc/webrtc.rs#L1234-L1274)
- [progress_provider.dart](file://app/lib/provider/progress_provider.dart#L0-L37)

## 数据完整性验证

为确保传输数据的完整性和安全性，LocalSend应用实施了多层次的验证机制。

### 哈希校验
应用使用SHA-256哈希算法对安全上下文（如证书）进行校验。在`security_helper.dart`中，`calculateHashOfCertificate`函数负责计算证书的哈希值：
```dart
String calculateHashOfCertificate(String certificate) {
  // 将PEM格式转换为DER格式
  final pemContent = certificate.replaceAll('\r\n', '\n').split('\n').where((line) => line.isNotEmpty && !line.startsWith('---')).join();
  final der = base64Decode(pemContent);
  // 计算SHA-256哈希
  return CryptoUtils.getHash(
    Uint8List.fromList(der),
    algorithmName: 'SHA-256',
  );
}
```
此哈希值用于唯一标识和验证证书的有效性。

### 错误恢复机制
系统通过以下方式实现错误恢复：
1. **状态管理**：`SessionStatus`枚举跟踪整个传输会话的状态，包括`sending`、`finished`、`finishedWithErrors`等。
2. **错误处理**：当文件传输失败时，状态会更新为`FileStatus.failed`，并记录错误信息。用户可以选择重试失败的文件。
3. **会话恢复**：对于后台传输，如果所有文件都成功或被跳过，会话会自动关闭；否则，会话保持打开状态，允许用户查看错误并决定后续操作。

**Section sources**
- [security_helper.dart](file://app/lib/util/security_helper.dart#L0-L39)
- [session_status.dart](file://common/lib/model/session_status.dart#L0-L12)

## 传输加密方案

LocalSend应用实现了端到端加密，确保数据在传输过程中的机密性和完整性。

### 端到端加密实现
加密方案基于非对称加密技术（RSA）和数字签名。核心流程如下：
1. **密钥生成**：每个设备在首次启动时生成一对RSA公私钥。
2. **自签名证书**：使用私钥生成自签名X.509证书，其中包含公钥。
3. **指纹生成**：对证书进行SHA-256哈希，生成唯一的指纹（Fingerprint），用于设备识别。
4. **安全上下文**：将私钥、公钥和证书存储在`StoredSecurityContext`中，构成设备的安全上下文。

```dart
StoredSecurityContext generateSecurityContext([AsymmetricKeyPair? keyPair]) {
  keyPair ??= CryptoUtils.generateRSAKeyPair();
  final privateKey = keyPair.privateKey as RSAPrivateKey;
  final publicKey = keyPair.publicKey as RSAPrivialKey;
  // ... 生成证书
  return StoredSecurityContext(
    privateKey: CryptoUtils.encodeRSAPrivateKeyToPemPkcs1(privateKey),
    publicKey: spki,
    certificate: certificate,
    certificateHash: hash,
  );
}
```

### 密钥交换流程
密钥交换通过WebRTC信令通道安全完成：
1. **Nonce交换**：双方交换随机生成的nonce。
2. **令牌生成**：发送方使用自己的私钥、接收到的nonce和公钥生成加密令牌。
3. **身份验证**：接收方使用发送方的公钥验证令牌的签名，确认发送方的身份。
4. **双向验证**：同样的流程反向执行，确保双方身份的真实性。

此流程有效防止了中间人攻击（MITM），因为攻击者无法伪造有效的数字签名。

**Section sources**
- [security_helper.dart](file://app/lib/util/security_helper.dart#L0-L39)
- [webrtc.rs](file://core/src/webrtc/webrtc.rs#L1322-L1373)

## 性能数据

虽然代码库中没有直接的性能测试数据，但可以通过分析代码逻辑推断出系统的性能特征。

### 传输速率
- **影响因素**：传输速率主要受网络带宽、延迟和设备性能影响。
- **并发传输**：应用支持并发上传，通过`uploadIsolateCount`参数控制并发数，可以充分利用多核CPU性能。
- **流控**：通过`wait_buffer_empty`函数监控数据通道的缓冲区，避免发送过快导致拥塞。

### 资源消耗
- **内存**：由于采用流式处理，内存消耗与分块大小（16 KiB）成正比，与文件总大小无关，实现了低内存占用。
- **CPU**：加密和解密操作会消耗CPU资源，但现代设备通常能轻松处理。
- **网络**：WebRTC的P2P连接减少了服务器中转的开销，直接在设备间传输数据，提高了效率。

在不同网络条件下，系统表现如下：
- **高速网络**（如局域网）：传输速率接近网络带宽上限，延迟低。
- **低速网络**（如移动网络）：传输速率受限于网络带宽，但流式处理仍能保证稳定传输。
- **高延迟网络**：有序传输模式会因等待确认而降低效率，但能保证数据完整性。

**Section sources**
- [send_provider.dart](file://app/lib/provider/network/send_provider.dart#L351-L384)
- [webrtc.rs](file://core/src/webrtc/webrtc.rs#L1234-L1274)

## 结论
LocalSend应用的数据传输模块是一个设计精良、安全可靠的系统。它利用WebRTC技术实现了高效的点对点文件传输，通过分块传输和流式处理优化了大文件的传输性能。端到端加密和多重验证机制确保了数据的安全性和完整性。尽管代码中缺乏详细的性能基准测试，但从其架构设计来看，该系统在各种网络条件下都能提供稳定、高效的文件传输服务。未来可以通过添加更精细的性能监控和自适应传输策略来进一步提升用户体验。
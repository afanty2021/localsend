# 核心功能实现

<cite>
**本文档中引用的文件**  
- [lib.rs](file://core/src/lib.rs)
- [crypto/mod.rs](file://core/src/crypto/mod.rs)
- [crypto/cert.rs](file://core/src/crypto/cert.rs)
- [crypto/hash.rs](file://core/src/crypto/hash.rs)
- [crypto/nonce.rs](file://core/src/crypto/nonce.rs)
- [crypto/token.rs](file://core/src/crypto/token.rs)
- [http/mod.rs](file://core/src/http/mod.rs)
- [http/server/mod.rs](file://core/src/http/server/mod.rs)
- [http/client/mod.rs](file://core/src/http/client/mod.rs)
- [http/dto.rs](file://core/src/http/dto.rs)
- [webrtc/mod.rs](file://core/src/webrtc/mod.rs)
- [webrtc/signaling.rs](file://core/src/webrtc/signaling.rs)
- [webrtc/webrtc.rs](file://core/src/webrtc/webrtc.rs)
- [model/discovery.rs](file://core/src/model/discovery.rs)
- [model/transfer.rs](file://core/src/model/transfer.rs)
- [util/base64.rs](file://core/src/util/base64.rs)
- [util/time.rs](file://core/src/util/time.rs)
- [Cargo.toml](file://core/Cargo.toml)
</cite>

## 目录
1. [项目结构](#项目结构)
2. [核心架构设计](#核心架构设计)
3. [加密功能实现](#加密功能实现)
4. [HTTP服务器实现](#http服务器实现)
5. [WebRTC信令实现](#webrtc信令实现)
6. [FFI接口设计](#ffi接口设计)
7. [性能基准与优化](#性能基准与优化)
8. [安全考虑](#安全考虑)

## 项目结构

LocalSend项目采用分层架构设计，核心功能由Rust实现，通过FFI暴露给Dart层。项目主要包含以下模块：

```mermaid
graph TD
A[LocalSend项目] --> B[Rust核心库]
A --> C[Dart前端]
A --> D[CLI工具]
B --> E[Crypto模块]
B --> F[HTTP模块]
F --> F1[服务器]
F --> F2[客户端]
B --> G[WebRTC模块]
G --> G1[信令]
G --> G2[P2P连接]
B --> H[模型定义]
B --> I[工具函数]
C --> J[FFI接口]
J --> B
D --> K[命令行接口]
K --> B
```

**Diagram sources**
- [lib.rs](file://core/src/lib.rs)
- [Cargo.toml](file://core/Cargo.toml)

**Section sources**
- [lib.rs](file://core/src/lib.rs)
- [Cargo.toml](file://core/Cargo.toml)

## 核心架构设计

LocalSend的核心架构采用模块化设计，各模块职责明确，通过清晰的接口进行通信。系统主要由三个核心模块组成：加密模块(crypto)、HTTP模块(http)和WebRTC模块(webrtc)。

```mermaid
classDiagram
class CryptoModule {
+verify_cert_from_pem(cert, public_key)
+verify_cert_from_der(cert, public_key)
+public_key_from_cert_pem(cert)
+public_key_from_cert_der(cert)
+sha256(data)
+generate_nonce()
+validate_nonce(nonce)
+generate_token_timestamp(key)
+generate_token_nonce(key, salt)
+verify_token_timestamp(public_key, token)
+verify_token_nonce(public_key, token, nonce)
}
class HttpModule {
+LsHttpServer
+start_with_port(port, tls_config)
+stop()
+TlsConfig
+cert : String
+private_key : String
}
class WebRtcModule {
+SignalingConnection
+connect(uri, info)
+start_listener()
+send_update(info)
+send_offer(session_id, target, sdp)
+send_answer(session_id, target, sdp)
+send_offer()
+accept_offer()
}
CryptoModule --> HttpModule : "提供证书验证和加密功能"
CryptoModule --> WebRtcModule : "提供身份验证和加密功能"
HttpModule --> WebRtcModule : "提供信令服务"
```

**Diagram sources**
- [lib.rs](file://core/src/lib.rs)
- [crypto/mod.rs](file://core/src/crypto/mod.rs)
- [http/mod.rs](file://core/src/http/mod.rs)
- [webrtc/mod.rs](file://core/src/webrtc/mod.rs)

**Section sources**
- [lib.rs](file://core/src/lib.rs)
- [Cargo.toml](file://core/Cargo.toml)

## 加密功能实现

### 证书验证与公钥提取

加密模块提供了完整的X.509证书验证功能，确保通信双方的身份可信。证书验证包括时间有效性检查、签名验证和公钥匹配验证。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Server as "服务器"
participant Crypto as "加密模块"
Client->>Server : 发送证书
Server->>Crypto : verify_cert_from_pem(cert, public_key)
Crypto->>Crypto : 检查时间有效性
Crypto->>Crypto : 验证签名
Crypto->>Crypto : 匹配公钥
Crypto-->>Server : 验证结果
Server-->>Client : 验证状态
```

**Diagram sources**
- [crypto/cert.rs](file://core/src/crypto/cert.rs)

**Section sources**
- [crypto/cert.rs](file://core/src/crypto/cert.rs)

### 哈希与随机数生成

加密模块实现了SHA-256哈希算法和安全随机数生成器，为令牌生成和数据完整性验证提供基础支持。

```mermaid
flowchart TD
A[输入数据] --> B[SHA-256哈希]
B --> C[32字节哈希值]
D[生成随机数] --> E[32字节随机数]
E --> F[验证随机数长度]
F --> G[16-128字节有效]
```

**Diagram sources**
- [crypto/hash.rs](file://core/src/crypto/hash.rs)
- [crypto/nonce.rs](file://core/src/crypto/nonce.rs)

**Section sources**
- [crypto/hash.rs](file://core/src/crypto/hash.rs)
- [crypto/nonce.rs](file://core/src/crypto/nonce.rs)

### 令牌生成与验证

令牌系统采用Ed25519数字签名算法，结合SHA-256哈希和时间戳/随机数，实现安全的身份验证机制。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Server as "服务器"
participant Crypto as "加密模块"
Client->>Crypto : generate_key()
Crypto-->>Client : 签名密钥
Client->>Crypto : generate_token_timestamp(key)
Crypto->>Crypto : 生成时间戳盐值
Crypto->>Crypto : 计算哈希
Crypto->>Crypto : 生成签名
Crypto-->>Client : 令牌
Client->>Server : 发送令牌
Server->>Crypto : verify_token_timestamp(public_key, token)
Crypto->>Crypto : 验证时间戳
Crypto->>Crypto : 验证签名
Crypto-->>Server : 验证结果
Server-->>Client : 访问权限
```

**Diagram sources**
- [crypto/token.rs](file://core/src/crypto/token.rs)

**Section sources**
- [crypto/token.rs](file://core/src/crypto/token.rs)

## HTTP服务器实现

### 服务器架构

HTTP服务器基于Hyper框架构建，支持HTTP和HTTPS协议，采用异步非阻塞I/O模型处理并发请求。

```mermaid
classDiagram
class LsHttpServer {
+start_with_port(port, tls_config)
+stop()
}
class AppState {
+received_nonce_map : LruCache<String, Vec<u8>>
+generated_nonce_map : LruCache<String, Vec<u8>>
}
class TlsConfig {
+cert : String
+private_key : String
}
class ClientInfo {
+ip : IpAddr
+cert : Option<Vec<u8>>
+extract_public_key()
+to_remote_key()
}
LsHttpServer --> AppState : "持有状态"
LsHttpServer --> TlsConfig : "可选TLS配置"
LsHttpServer --> ClientInfo : "客户端信息"
AppState --> LruCache : "LRU缓存"
```

**Diagram sources**
- [http/server/mod.rs](file://core/src/http/server/mod.rs)

**Section sources**
- [http/server/mod.rs](file://core/src/http/server/mod.rs)

### 请求处理流程

HTTP服务器实现了非交互式身份验证流程，通过nonce交换机制防止重放攻击。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Server as "服务器"
participant HttpServer as "HTTP服务器"
Client->>Server : POST /api/localsend/v3/nonce
Server->>HttpServer : 解析请求
HttpServer->>HttpServer : 生成随机数
HttpServer->>HttpServer : 验证客户端随机数
HttpServer->>HttpServer : 存储随机数对
HttpServer-->>Server : 返回新随机数
Server-->>Client : 200 OK + 新随机数
```

**Diagram sources**
- [http/server/mod.rs](file://core/src/http/server/mod.rs)

**Section sources**
- [http/server/mod.rs](file://core/src/http/server/mod.rs)

### HTTP客户端实现

HTTP客户端模块负责与其他LocalSend实例通信，支持HTTPS双向认证。

```mermaid
classDiagram
class LsHttpClient {
+try_new(private_key, cert)
+nonce(protocol, ip, port)
+register(protocol, ip, port, payload)
+prepare_upload(protocol, ip, port, public_key, payload)
+upload(protocol, ip, port, session_id, file_id, token, binary)
+cancel(protocol, ip, port, session_id)
}
class RegisterResult {
+public_key : Option<String>
+body : RegisterResponseDto
}
LsHttpClient --> RegisterResult : "返回注册结果"
LsHttpClient --> reqwest : : Client : "底层HTTP客户端"
```

**Diagram sources**
- [http/client/mod.rs](file://core/src/http/client/mod.rs)

**Section sources**
- [http/client/mod.rs](file://core/src/http/client/mod.rs)

## WebRTC信令实现

### 信令协议设计

WebRTC信令采用WebSocket协议，定义了清晰的消息类型和数据结构，支持设备发现和SDP交换。

```mermaid
classDiagram
class WsServerMessage {
+Hello{client, peers}
+Join{peer}
+Update{peer}
+Left{peerId}
+Offer{WsServerSdpMessage}
+Answer{WsServerSdpMessage}
+Error{code}
}
class WsClientMessage {
+Update{info}
+Offer{WsClientSdpMessage}
+Answer{WsClientSdpMessage}
}
class ClientInfo {
+id : Uuid
+alias : String
+version : String
+device_model : Option<String>
+device_type : Option<DeviceType>
+token : String
}
class WsServerSdpMessage {
+peer : ClientInfo
+session_id : String
+sdp : String
}
class WsClientSdpMessage {
+session_id : String
+target : Uuid
+sdp : String
}
WsServerMessage --> ClientInfo : "包含"
WsServerMessage --> WsServerSdpMessage : "包含"
WsClientMessage --> ClientInfo : "包含"
WsClientMessage --> WsClientSdpMessage : "包含"
```

**Diagram sources**
- [webrtc/signaling.rs](file://core/src/webrtc/signaling.rs)

**Section sources**
- [webrtc/signaling.rs](file://core/src/webrtc/signaling.rs)

### 信令连接流程

信令连接建立过程包括客户端信息编码、WebSocket连接和握手消息交换。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Server as "信令服务器"
participant Signaling as "信令模块"
Client->>Signaling : connect(uri, info)
Signaling->>Signaling : 编码客户端信息
Signaling->>Signaling : Base64编码
Signaling->>Server : WebSocket连接 + 查询参数
Server-->>Signaling : WebSocket连接建立
Signaling->>Signaling : 启动发送任务
Signaling->>Signaling : 启动接收任务
Signaling->>Server : 等待Hello消息
Server->>Signaling : Hello{client, peers}
Signaling-->>Client : 返回连接对象
```

**Diagram sources**
- [webrtc/signaling.rs](file://core/src/webrtc/signaling.rs)

**Section sources**
- [webrtc/signaling.rs](file://core/src/webrtc/signaling.rs)

### P2P连接建立

P2P连接建立过程结合了信令交换和安全验证，确保连接的安全性。

```mermaid
sequenceDiagram
participant Sender as "发送方"
participant Receiver as "接收方"
participant Signaling as "信令服务器"
Sender->>Signaling : send_offer(session_id, target, sdp)
Signaling->>Receiver : 转发Offer
Receiver->>Signaling : send_answer(session_id, sdp)
Signaling->>Sender : 转发Answer
Sender->>Sender : 设置远程描述
Receiver->>Receiver : 设置远程描述
Sender->>Receiver : ICE候选者交换
Receiver->>Sender : ICE候选者交换
Sender->>Sender : 连接建立完成
Receiver->>Receiver : 连接建立完成
```

**Diagram sources**
- [webrtc/webrtc.rs](file://core/src/webrtc/webrtc.rs)

**Section sources**
- [webrtc/webrtc.rs](file://core/src/webrtc/webrtc.rs)

## FFI接口设计

### API设计模式

Rust核心库通过Flutter Rust Bridge(FLB)暴露API给Dart层，采用异步函数和通道模式处理数据流。

```mermaid
classDiagram
class DartLayer {
+Rust API调用
+Future/Promise
+Stream
}
class FFIInterface {
+frb_generated.dart
+frb_generated.rs
}
class RustCore {
+异步函数
+mpsc通道
+Arc<Mutex>
}
DartLayer --> FFIInterface : "调用"
FFIInterface --> RustCore : "调用"
RustCore --> FFIInterface : "返回"
FFIInterface --> DartLayer : "返回"
```

**Diagram sources**
- [app/lib/rust/api](file://app/lib/rust/api)
- [rust/src/api](file://rust/src/api)

**Section sources**
- [app/lib/rust/frb_generated.dart](file://app/lib/rust/frb_generated.dart)
- [rust/src/frb_generated.rs](file://rust/src/frb_generated.rs)

### 参数传递方式

参数传递采用序列化机制，复杂数据结构通过JSON序列化传输，二进制数据通过通道流式传输。

```mermaid
flowchart TD
A[Dart参数] --> B[序列化为JSON]
B --> C[通过FFI传递]
C --> D[Rust反序列化]
D --> E[处理逻辑]
E --> F[结果序列化]
F --> G[通过FFI返回]
G --> H[Dart反序列化]
H --> I[返回Future]
J[二进制数据] --> K[mpsc::Sender]
K --> L[流式传输]
L --> M[mpsc::Receiver]
M --> N[处理数据块]
```

**Diagram sources**
- [core/src/model](file://core/src/model)
- [common/lib/model](file://common/lib/model)

**Section sources**
- [core/src/model](file://core/src/model)
- [common/lib/model](file://common/lib/model)

## 性能基准与优化

### 连接池管理

HTTP客户端和服务器采用LRU缓存机制管理nonce，避免重复验证，提高性能。

```mermaid
classDiagram
class LruCache {
+new(capacity)
+put(key, value)
+get(key)
+capacity()
}
class AppState {
+received_nonce_map : LruCache<String, Vec<u8>>
+generated_nonce_map : LruCache<String, Vec<u8>>
}
class LsHttpClient {
+received_nonce_map : Arc<Mutex<LruCache<String, Vec<u8>>>>
+generated_nonce_map : Arc<Mutex<LruCache<String, Vec<u8>>>>
}
LruCache --> AppState : "用于状态管理"
LruCache --> LsHttpClient : "用于客户端管理"
```

**Diagram sources**
- [http/server/mod.rs](file://core/src/http/server/mod.rs)
- [http/client/mod.rs](file://core/src/http/client/mod.rs)

**Section sources**
- [http/server/mod.rs](file://core/src/http/server/mod.rs)
- [http/client/mod.rs](file://core/src/http/client/mod.rs)

### 内存使用优化

系统采用多种内存优化策略，包括零拷贝、流式处理和对象重用。

```mermaid
flowchart TD
A[数据接收] --> B[零拷贝处理]
B --> C[流式解析]
C --> D[对象池重用]
D --> E[及时释放]
E --> F[内存使用优化]
G[大文件传输] --> H[分块处理]
H --> I[流式传输]
I --> J[避免内存峰值]
J --> K[内存使用优化]
```

**Diagram sources**
- [webrtc/webrtc.rs](file://core/src/webrtc/webrtc.rs)
- [http/server/collect_to_json.rs](file://core/src/http/server/collect_to_json.rs)

**Section sources**
- [webrtc/webrtc.rs](file://core/src/webrtc/webrtc.rs)
- [http/server/collect_to_json.rs](file://core/src/http/server/collect_to_json.rs)

## 安全考虑

### DDoS攻击防护

系统通过多种机制防止DDoS攻击，包括连接限制、超时设置和资源回收。

```mermaid
flowchart TD
A[新连接] --> B[连接限制检查]
B --> C{超过限制?}
C --> |是| D[拒绝连接]
C --> |否| E[设置超时]
E --> F[处理请求]
F --> G[资源使用监控]
G --> H{资源超限?}
H --> |是| I[终止连接]
H --> |否| J[正常处理]
J --> K[连接关闭]
K --> L[资源回收]
```

**Diagram sources**
- [http/server/mod.rs](file://core/src/http/server/mod.rs)
- [webrtc/webrtc.rs](file://core/src/webrtc/webrtc.rs)

**Section sources**
- [http/server/mod.rs](file://core/src/http/server/mod.rs)
- [webrtc/webrtc.rs](file://core/src/webrtc/webrtc.rs)

### 证书验证最佳实践

证书验证遵循最佳实践，包括完整的证书链验证、时间有效性检查和公钥匹配。

```mermaid
flowchart TD
A[接收证书] --> B[解析PEM/DER]
B --> C[检查时间有效性]
C --> D{有效?}
D --> |否| E[拒绝连接]
D --> |是| F[验证签名]
F --> G{有效?}
G --> |否| H[拒绝连接]
G --> |是| I[匹配公钥]
I --> J{匹配?}
J --> |否| K[拒绝连接]
J --> |是| L[接受连接]
```

**Diagram sources**
- [crypto/cert.rs](file://core/src/crypto/cert.rs)

**Section sources**
- [crypto/cert.rs](file://core/src/crypto/cert.rs)
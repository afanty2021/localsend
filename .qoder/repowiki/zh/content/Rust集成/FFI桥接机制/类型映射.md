# 类型映射

<cite>
**本文档引用的文件**  
- [flutter_rust_bridge.yaml](file://app/flutter_rust_bridge.yaml)
- [frb_generated.dart](file://app/lib/rust/frb_generated.dart)
- [lib.rs](file://app/rust/src/lib.rs)
- [model.rs](file://app/rust/src/api/model.rs)
- [webrtc.rs](file://app/rust/src/api/webrtc.rs)
- [frb_generated.rs](file://app/rust/src/frb_generated.rs)
</cite>

## 目录
1. [简介](#简介)
2. [基本类型映射](#基本类型映射)
3. [复杂类型映射](#复杂类型映射)
4. [自定义结构体和枚举映射](#自定义结构体和枚举映射)
5. [泛型类型处理](#泛型类型处理)
6. [类型映射表](#类型映射表)
7. [错误处理与调试](#错误处理与调试)
8. [数据结构设计最佳实践](#数据结构设计最佳实践)

## 简介
本项目使用Flutter Rust Bridge实现Dart与Rust之间的类型映射机制，通过自动生成的桥接代码实现跨语言数据交换。类型映射机制基于`flutter_rust_bridge`框架，通过`#[frb(mirror(...))]`属性标记需要桥接的Rust类型，自动生成相应的Dart类型和序列化/反序列化代码。

**Section sources**
- [flutter_rust_bridge.yaml](file://app/flutter_rust_bridge.yaml#L1-L4)
- [frb_generated.dart](file://app/lib/rust/frb_generated.dart#L1-L25)

## 基本类型映射
Dart与Rust之间的基本类型映射通过SSE（Server-Sent Events）编码机制实现，支持整数、字符串、布尔值等基本类型。

- **整数类型**：Dart的`int`与Rust的`i32`、`u32`等类型直接映射
- **字符串类型**：Dart的`String`与Rust的`String`类型双向映射
- **布尔类型**：Dart的`bool`与Rust的`bool`类型直接对应
- **浮点类型**：Dart的`double`与Rust的`f64`类型映射

这些基本类型通过自动生成的编码函数进行序列化，如`sse_encode_String`、`sse_decode_String`等。

**Section sources**
- [frb_generated.dart](file://app/lib/rust/frb_generated.dart#L100-L200)
- [frb_generated.rs](file://app/rust/src/frb_generated.rs#L100-L300)

## 复杂类型映射
复杂类型映射包括集合类型和二进制数据的处理。

### 集合类型
- **List/Vec**：Dart的`List<T>`与Rust的`Vec<T>`相互映射，通过`sse_encode_list_T`和`sse_decode_list_T`函数处理
- **Set**：Dart的`Set<String>`与Rust的`HashSet<String>`映射，使用`sse_encode_Set_String_None`等函数
- **Map**：Dart的`Map<String, T>`与Rust的`HashMap<String, T>`映射

### 二进制数据
- **Uint8List**：Dart的`Uint8List`与Rust的`Vec<u8>`或`Bytes`类型映射
- **Stream处理**：通过`StreamSink`机制实现流式数据传输，如文件传输过程中的数据流

**Section sources**
- [frb_generated.dart](file://app/lib/rust/frb_generated.dart#L500-L800)
- [frb_generated.rs](file://app/rust/src/frb_generated.rs#L500-L1000)

## 自定义结构体和枚举映射
自定义类型通过`#[frb(mirror(...))]`属性进行桥接，生成相应的Dart类和枚举。

### 结构体映射
Rust结构体使用`#[frb(mirror(...))]`标记，生成对应的Dart类：

```rust
#[frb(mirror(FileDto))]
pub struct _FileDto {
    pub id: String,
    pub file_name: String,
    pub size: u64,
    pub file_type: String,
    pub sha256: Option<String>,
    pub preview: Option<String>,
    pub metadata: Option<FileMetadata>,
}
```

对应的Dart类自动生成，包含相同的字段和类型。

### 枚举映射
Rust枚举同样使用`#[frb(mirror(...))]`标记：

```rust
#[frb(mirror(RTCStatus))]
pub enum _RTCStatus {
    SdpExchanged,
    Connected,
    PinRequired,
    TooManyAttempts,
    Declined,
    Sending,
    Finished,
    Error(String),
}
```

生成的Dart枚举包含相同的变体，复杂变体（如包含数据的枚举）会生成相应的数据类。

**Section sources**
- [model.rs](file://app/rust/src/api/model.rs#L30-L70)
- [webrtc.rs](file://app/rust/src/api/webrtc.rs#L300-L350)

## 泛型类型处理
泛型类型在桥接时需要特别处理，主要限制包括：

1. **泛型参数限制**：仅支持有限的泛型参数类型，通常需要具体化泛型参数
2. **集合泛型**：`Vec<T>`、`HashMap<K, V>`等标准集合的泛型支持较好
3. **复杂泛型**：嵌套泛型或复杂泛型结构可能需要手动实现桥接逻辑

在实际使用中，建议将泛型类型具体化后再进行桥接，或通过包装类型来简化泛型处理。

**Section sources**
- [webrtc.rs](file://app/rust/src/api/webrtc.rs#L100-L150)
- [frb_generated.rs](file://app/rust/src/frb_generated.rs#L2000-L2500)

## 类型映射表
以下是Dart与Rust类型的主要映射关系：

| Dart类型 | Rust类型 | 说明 |
|---------|---------|------|
| `int` | `i32`, `u32` | 整数类型映射 |
| `String` | `String` | 字符串类型映射 |
| `bool` | `bool` | 布尔类型映射 |
| `double` | `f64` | 浮点数类型映射 |
| `List<T>` | `Vec<T>` | 列表/向量映射 |
| `Set<String>` | `HashSet<String>` | 集合类型映射 |
| `Map<String, T>` | `HashMap<String, T>` | 映射类型映射 |
| `Uint8List` | `Vec<u8>`, `Bytes` | 二进制数据映射 |
| `Future<T>` | `impl Future<Output = T>` | 异步操作映射 |
| `Stream<T>` | `StreamSink<T>` | 流式数据映射 |

**Section sources**
- [frb_generated.dart](file://app/lib/rust/frb_generated.dart#L100-L1000)
- [frb_generated.rs](file://app/rust/src/frb_generated.rs#L100-L2000)

## 错误处理与调试
类型映射过程中可能出现多种错误，需要相应的调试策略。

### 常见错误类型
- **类型不匹配**：Dart与Rust类型定义不一致导致的序列化失败
- **序列化失败**：复杂类型序列化过程中出现的编码错误
- **空值处理**：`Option<T>`与可空类型处理不当
- **生命周期问题**：Rust Opaque类型生命周期管理错误

### 调试技巧
1. **检查生成代码**：查看`frb_generated.dart`和`frb_generated.rs`中的编码/解码函数
2. **验证类型定义**：确保Dart与Rust的类型定义完全匹配
3. **使用Option处理**：对可能为空的字段使用`Option<T>`和可空类型
4. **日志调试**：启用调试日志查看序列化过程

```dart
// 启用调试日志
await RustLib.init();
await crateApiLoggingEnableDebugLogging();
```

**Section sources**
- [frb_generated.dart](file://app/lib/rust/frb_generated.dart#L1000-L1500)
- [webrtc.rs](file://app/rust/src/api/webrtc.rs#L1-L50)

## 数据结构设计最佳实践
为了确保类型映射的正确性和性能，建议遵循以下设计原则：

### 结构体设计
1. **使用基本类型**：优先使用`String`、`i32`、`bool`等基本类型
2. **明确Option使用**：对可空字段明确使用`Option<T>`
3. **避免复杂嵌套**：减少深层次的结构体嵌套

### 枚举设计
1. **简单变体优先**：尽量使用不包含数据的简单变体
2. **统一错误类型**：定义统一的错误枚举类型
3. **避免过大枚举**：控制枚举变体数量，提高可维护性

### 性能优化
1. **批量传输**：对于大量数据，考虑批量传输而非单个对象传输
2. **流式处理**：大文件传输使用`StreamSink`进行流式处理
3. **缓存机制**：对频繁访问的数据实现缓存

```rust
// 良好的结构体设计示例
#[frb(mirror(FileDto))]
pub struct _FileDto {
    pub id: String,
    pub file_name: String,
    pub size: u64,
    pub file_type: String,
    pub sha256: Option<String>,
}
```

**Section sources**
- [model.rs](file://app/rust/src/api/model.rs#L1-L73)
- [webrtc.rs](file://app/rust/src/api/webrtc.rs#L1-L515)